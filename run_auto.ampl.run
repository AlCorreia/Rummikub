reset;

option solver cplexamp;

param iter; # Nombre d'iterations
param i_alea; # Numero aleatoire
param j_alea; # Numero aleatoire
param fin; #Jalon
param carte_reserve integer; # Nombre des cartes a la pioche
param compteur; 

model declaration_rummikub_joker.ampl;

param datfile symbolic;
if $datfile != "" then {
    # On recupere le parametre
    let datfile := $datfile;
} else {
    # On n a pas passe de parametre $datfile
    let datfile := "instance_rummikub_joker.ampl.dat";
}
display datfile;
data (datfile);

model build_groups_joker.ampl;
model model_joker.ampl.mod;

param somme;
	
let carte_reserve := NB_BAR + NB_NUM*NB_COUL*NB_MUL - sum {m in 0..NB_NUM, n in 1..NB_COUL} (carte_main[m,n] + carte_table[m,n]);

printf"\nCarte_reserve: %d \n", carte_reserve;

# Impression de la configuration initiale
printf "\nCONFIGURATION INITIALE \n";
printf"\nCarte_table:";
for{m in 0..NB_NUM} {
	printf"\n%d: ",m;
	for{n in 1..NB_COUL} {
		if m = 0 && n > 1 then 
				printf"J ";
		else printf"%d ", carte_table[m,n];
	}
}
printf"\nCarte_main:";
for{m in 0..NB_NUM} {
	printf"\n%d: ",m;
	for{n in 1..NB_COUL} {
		if m = 0 && n > 1 then 
				printf"J ";
		else printf"%d ", carte_main[m,n];
	}
}
# ITERATIONS
let iter := 0;
repeat until carte_reserve = 0 {
	printf "\nIteration %d \n", iter;
	
	solve;
	
	# Impression et mise a jour de carte_table apres solve
	printf"\nCarte_table:";
	for{m in 0..NB_NUM} {
		printf"\n%d: ",m;
		for{n in 1..NB_COUL} {
			let carte_table[m,n] := carte_table[m,n] + y[m,n];
			let carte_main[m,n] := carte_main[m,n] - y[m,n];
			if m = 0 && n > 1 then 
				printf"J ";
			else printf"%d ", carte_table[m,n];
		}
	}
	
	# Impression du groupe de chaque joker
	let compteur := 0;
	for{o in 1..NB_GROUPES}{
		if s[o,0]*x[o] > 0 then {
			let compteur := compteur + 1;
			printf"\nGroupe Joker %d: ", compteur;
			for{m in 1..NB_NUM} {
				for{n in 1..NB_COUL} {
					if s[o,(n-1)*NB_NUM + m] > 0 then {
					printf"(%d, %d) ", m, n;
					}
				}
			}
			printf"\n";
		}
	}
	
	# Calcule de nombre des cartes a la main
	let somme := carte_main[0,1] + sum {m in 1..NB_NUM, n in 1..NB_COUL} carte_main[ m, n];
	printf"\nNOMBRE DES CARTES A LA MAIN: %d \n",somme;
	if somme = 0 then {
		printf"\nJOUEUR a gagne! \n";
		break;
		break;
	};
	
	commands alea.com.mod; # On pioche une carte a chaque tour
	let carte_main[i_alea, j_alea] := 1; # Mise a jour de carte_main
	printf"\nCarte_reserve: %d \n", carte_reserve;
	let carte_reserve := carte_reserve - 1; # Mise a jour de carte_reserve
	let iter := iter + 1;
	
	# Impression de carte_main
	printf"\nCarte_main:";
	for{m in 0..NB_NUM} {
		printf"\n%d: ",m;
		for{n in 1..NB_COUL} {
			if m = 0 && n > 1 then  
				printf"J ";
			else printf"%d ", carte_main[m,n];
		}
	}
}

# Impression de la configuration finale
printf "\nCONFIGURATION FINALE \n";
printf"\nCarte_table:";
for{m in 0..NB_NUM} {
	printf"\n%d: ",m;
	for{n in 1..NB_COUL} {
		if m = 0 && n > 1 then 
				printf"J ";
		else printf"%d ", carte_table[m,n];
	}
}
printf"\n\nCarte_main:";
for{m in 0..NB_NUM} {
	printf"\n%d: ",m;
	for{n in 1..NB_COUL} {
		if m = 0 && n > 1 then 
				printf"J ";
		else printf"%d ", carte_main[m,n];
	}
}
