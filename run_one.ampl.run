reset;

option solver cplexamp;

param iter;
param i_alea;
param j_alea;
param j_tour;
param fin;
param carte_reserve integer;

printf"OI";

model declaration_rummikub.ampl.mod;
data instance_rummikub.ampl.dat;
model build_groups.ampl.dat;
model model.mod;

let i := 1;
repeat until i = NB_JOUEURS + 1 {
	let j := 1;
	repeat until j = NB_CARTES + 1 {
		commands distribuition.ampl.mod;
		let main[i, i_alea, j_alea] := main[i, i_alea, j_alea] + 1;
		let mont[i_alea, j_alea] := mont[i_alea, j_alea] - 1; 
		let j := j + 1;
	};
	let i := i + 1;
};
printf "\nMONT \n";

for{m in 1..NB_NUM} {
	for{n in 1..NB_COUL} {
		printf"%d ", mont[m,n];
	}
	printf"\n";
}

let carte_reserve := NB_NUM*NB_COUL - sum {m in 1..NB_NUM, n in 1..NB_COUL} (carte_main[m,n] + carte_table[m,n]);

printf"\nCarte_reserve: %d \n", carte_reserve;

printf "\nCONFIGURATION INITIALE \n";
printf"\nCarte_table: \n";
for{m in 1..NB_NUM} {
	for{n in 1..NB_COUL} {
		printf"%d ", carte_table[m,n];
	}
	printf"\n";
}
printf"\nCarte_main: \n";
for {o in 1..NB_JOUEURS} {
	printf"JOUEUR %d \n", o;
	for{m in 1..NB_NUM} {
		for{n in 1..NB_COUL} {
			printf"%d ", main[o,m,n];
		};
		printf"\n";
	};
};

let iter := 1;
repeat until carte_reserve = 0 {
	printf "\nIteration %d \n", iter;
	let j_tour := iter mod NB_JOUEURS;
	if j_tour = 0 then
		let j_tour := NB_JOUEURS;
	for{m in 1..NB_NUM} {
		for{n in 1..NB_COUL} {
			let carte_main[m,n] := main[j_tour, m, n];
		}
		printf"\n";
	}
	
	solve;
	
	printf"\nCarte_table: \n";
	for{m in 1..NB_NUM} {
		for{n in 1..NB_COUL} {
			let carte_table[m,n] := carte_table[m,n] + y[m,n];
			let main[j_tour, m, n] := main[j_tour, m, n] - y[m,n];
			let carte_main[m,n] := carte_main[m,n] - y[m,n];
			printf"%d ", carte_table[m,n];
		}
		printf"\n";
	}
	
	if sum{m in 1..NB_NUM, n in 1..NB_COUL} y[m, n] = 0 then {  
		commands distribuition.ampl.mod;
		let main[j_tour, i_alea, j_alea] := 1;
		let carte_main[i_alea, j_alea] := 1;
		let carte_reserve := carte_reserve - 1;
		let mont[i_alea, j_alea] := mont[i_alea, j_alea] - 1; 
		printf"\nCarte_reserve: %d \n", carte_reserve;
	}
	let iter := iter + 1;
	
	printf"\nJOUEUR %d: \n", j_tour;
	for{m in 1..NB_NUM} {
		for{n in 1..NB_COUL} {
			printf"%d ", carte_main[m,n];
		}
		printf"\n";
	}
}
solve;
printf "\nCONFIGURATION FINALE \n";
printf"\nCarte_table: \n";
for{m in 1..NB_NUM} {
	for{n in 1..NB_COUL} {
		let carte_table[m,n] := carte_table[m,n] + y[m,n];
		let carte_main[m,n] := carte_main[m,n] - y[m,n];
		printf"%d ", carte_table[m,n];
	}
	printf"\n";
}
printf"\nCarte_main: \n";
for{m in 1..NB_NUM} {
	for{n in 1..NB_COUL} {
		printf"%d ", carte_main[m,n];
	}
	printf"\n";
}
